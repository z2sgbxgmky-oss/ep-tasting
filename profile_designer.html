<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Wine Profile Designer</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --burgundy: #800020;
            --text-main: #2d3748;
            --border-light: #e2e8f0;
            --flaw-color: #c53030;
            --trait-color: #2b6cb0;
            --pro-color: #2f855a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;f
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            padding-bottom: 90px;
            box-sizing: border-box;
        }

        .hidden { display: none !important; }

        /* --- HEADER --- */
        header { display: flex; flex-direction: column; gap: 15px; border-bottom: 2px solid var(--border-light); padding-bottom: 20px; margin-bottom: 25px; }
        .header-top { display: flex; justify-content: space-between; align-items: center; }
        h1 { margin: 0; font-size: 1.4rem; color: var(--burgundy); font-weight: 800; }
        .step-badge { font-size: 0.8rem; background: #edf2f7; padding: 4px 8px; border-radius: 6px; color: #718096; font-weight: 600; }
        

.template-loader {
    display: flex;
    gap: 10px;
    background: #f7fafc;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid var(--border-light);
    align-items: center;
    
    flex-wrap: wrap; /* <--- ALLOW WRAPPING */
}

.template-loader select {
    flex: 1 1 200px; /* Grow: 1, Shrink: 1, Basis: 200px. 
                        If less than 200px space remains, it will trigger a wrap */
    
    /* ... keep other styles (height: 42px, etc) ... */
    height: 42px;
    padding: 0 10px;
    border: 1px solid #cbd5e0;
    border-radius: 6px;
    font-size: 0.95rem;
    background: white;
    box-sizing: border-box;
    min-width: 0;
}

/* Ensure buttons don't stretch weirdly if wrapped alone */
.btn-load {
    /* ... keep styles ... */
    flex: 0 0 auto;
    height: 42px;
    background: var(--burgundy);
    color: white;
    border: none;
    padding: 0 20px;
    font-weight: 700;
    border-radius: 6px;
    cursor: pointer;
    white-space: nowrap;
}

.btn-del-header {
    flex: 0 0 42px;
    height: 42px;
    background: white;
    color: #718096;          /* Soft slate gray icon */
    border: 1px solid #cbd5e0; /* Matches the Select border */
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;       /* Slightly larger icon */
    line-height: 1;
    padding: 0;
}


        /* --- STEP 1: STRUCTURE --- */
        .meta-grid { display: grid; gap: 15px; margin-bottom: 30px; }
        @media (min-width: 768px) { .meta-grid { grid-template-columns: 1fr 1fr; } }
        .input-group label { display: block; font-size: 0.75rem; font-weight: 700; color: #718096; margin-bottom: 6px; text-transform: uppercase; }
        .input-group input { width: 100%; padding: 10px; border: 2px solid var(--border-light); border-radius: 8px; font-size: 0.95rem; box-sizing: border-box; }
        
        .structure-grid { display: grid; gap: 30px; }
        @media (min-width: 768px) { .structure-grid { grid-template-columns: 1fr 1fr 1fr; gap: 15px; } }
        
        .section-header { font-size: 1.1rem; font-weight: 900; color: var(--text-main); text-align: center; padding-bottom: 8px; border-bottom: 3px solid var(--burgundy); margin-bottom: 5px; }
        .list-card { background: #fff; border: 1px solid var(--border-light); border-radius: 8px; padding: 12px; display: flex; flex-direction: column; gap: 8px; }
        .list-title { font-size: 0.7rem; font-weight: 800; text-transform: uppercase; display: flex; justify-content: space-between; }
        .lc-flaws { border-left: 4px solid var(--flaw-color); } .lc-flaws .list-title { color: var(--flaw-color); }
        .lc-traits { border-left: 4px solid var(--trait-color); } .lc-traits .list-title { color: var(--trait-color); }
        .lc-pros { border-left: 4px solid var(--pro-color); } .lc-pros .list-title { color: var(--pro-color); }
        
        .item-row { display: flex; gap: 8px; align-items: center; }
        .item-row input { flex-grow: 1; padding: 8px; border: 1px solid var(--border-light); border-radius: 6px; }
        .btn-del { background: transparent; color: #e53e3e; cursor: pointer; font-size: 1.2rem; border: none; }
        .btn-add { width: 100%; padding: 10px; background: #f7fafc; border: 1px dashed #cbd5e0; color: #4a5568; font-weight: 600; cursor: pointer; border-radius: 6px; }

        .global-grid { display: grid; gap: 20px; margin-top: 40px; padding-top: 20px; border-top: 2px dashed var(--border-light); }
        @media (min-width: 768px) { .global-grid { grid-template-columns: 1fr 1fr 1fr; } }

        /* --- STEP 2: LOGIC --- */
        .logic-section { margin-bottom: 40px; }
        .logic-title { font-size: 1.1rem; font-weight: 800; color: #2d3748; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #e2e8f0; padding-bottom: 10px; }
        .logic-card { background: #fdfdfd; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; }
        
        .sub-header { font-size: 0.8rem; text-transform: uppercase; font-weight: 800; color: #718096; margin: 20px 0 10px 0; letter-spacing: 0.5px; }
        
        .slider-row { margin-bottom: 15px; }
        .slider-header { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9rem; font-weight: 600; }
        .slider-val { color: var(--burgundy); font-weight: 800; }
        input[type=range] { width: 100%; accent-color: var(--burgundy); height: 6px; background: #e2e8f0; border-radius: 5px; cursor: pointer; }

        /* Item Scoring UI */
        .score-grid { display: grid; gap: 10px; }
        .score-row { display: flex; flex-direction: column; background: white; padding: 10px; border: 1px solid #edf2f7; border-radius: 6px; }
        .score-top { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .score-lbl { font-weight: 600; font-size: 0.9rem; }
        .score-val { font-weight: 800; font-size: 0.9rem; }
        .val-pos { color: var(--pro-color); }
        .val-neg { color: var(--flaw-color); }

        /* AI Textareas */
        .ai-input-group { margin-bottom: 15px; }
        .ai-input-group label { display: block; font-size: 0.8rem; font-weight: 700; color: #4a5568; margin-bottom: 6px; }
        .ai-input-group textarea { width: 100%; padding: 12px; border: 1px solid #cbd5e0; border-radius: 8px; font-family: inherit; font-size: 0.95rem; resize: vertical; background: white; box-sizing: border-box; }
        .ai-input-group textarea:focus { border-color: var(--burgundy); outline: none; }

        /* Footer */
.footer { position: fixed; bottom: 0; left: 0; right: 0; background: white; border-top: 1px solid var(--border-light); padding: 15px 20px; padding-bottom: calc(15px + env(safe-area-inset-bottom)); display: flex; justify-content: space-between; align-items: center; box-shadow: 0 -4px 12px rgba(0,0,0,0.08); z-index: 100; }
        .btn-back { background: transparent; color: #718096; border: 1px solid #cbd5e0; padding: 12px 20px; font-weight: 700; border-radius: 8px; cursor: pointer; }
        .btn-next { background: var(--burgundy); color: white; border: none; padding: 12px 25px; font-size: 1rem; font-weight: 700; border-radius: 8px; cursor: pointer; }

    </style>
</head>
<body>

<div class="container">
    <header>
        <div class="header-top">
            <h1>Profile Designer</h1>
            <!-- Badge + Help Button Wrapper -->
<div style="display:flex; align-items:center; gap:10px;">
    <!-- Step 1 Help Button (New) -->
    <button id="btnDesignHelp" onclick="toggleDesignGuide()" style="background:#edf2f7; color:#2d3748; border:1px solid #cbd5e0; width:28px; height:28px; border-radius:50%; font-weight:bold; cursor:pointer; font-family:serif; font-style:italic;" title="Read Design Guidelines">i</button>
    
    <!-- Step 2 Help Button (Existing, initially hidden) -->
    <button id="btnHelp" onclick="toggleGuide()" class="hidden" style="background:#edf2f7; color:#2d3748; border:1px solid #cbd5e0; width:28px; height:28px; border-radius:50%; font-weight:bold; cursor:pointer; font-family:serif; font-style:italic;" title="Read Scoring Methodology">i</button>
    
    <span id="stepBadge" class="step-badge">Step 1: Structure</span>
</div>
        </div>
        <div id="loaderBox" class="template-loader" style="display:flex; gap:8px; align-items:center;">
            <select id="templateSelector" style="flex-grow:1;" onchange="updateDeleteVisibility()">
                <option value="">Choose a template or start from scratch...</option>
            </select>
            <button class="btn-load" onclick="loadSelectedTemplate()">LOAD</button>
            <button id="btnDeleteTemplate" class="btn-del-header" style="display:none;" onclick="deleteSelectedTemplate()" title="Delete this profile">ðŸ—‘</button>
        </div>

    </header>


    <!-- STEP 1: STRUCTURE -->
    <div id="step1">
        <div class="meta-grid">
            <div class="input-group"><label>Profile Name</label><input type="text" id="meta_name"></div>
            <div class="input-group"><label>Wine Type</label><input type="text" id="meta_wineType"></div>
        </div>

        <div class="structure-grid">
            <div id="col_nose" class="section-col"></div>
            <div id="col_palate" class="section-col"></div>
            <div id="col_finish" class="section-col"></div>
        </div>

        <div class="global-grid">
            <div class="section-col"><div class="section-header" style="font-size:0.9rem; border-color:#cbd5e0;">BALANCE</div><div class="list-card" id="editor_balance" style="border-left:4px solid #718096;"></div></div>
            <div class="section-col"><div class="section-header" style="font-size:0.9rem; border-color:#cbd5e0;">PROFILE</div><div class="list-card" id="editor_profile" style="border-left:4px solid #718096;"></div></div>
            <div class="section-col"><div class="section-header" style="font-size:0.9rem; border-color:#cbd5e0;">TRUE TO</div><div class="list-card" id="editor_true_to" style="border-left:4px solid #718096;"></div></div>
        </div>
    </div>

    <!-- STEP 2: LOGIC -->
    <div id="step2" class="hidden">
        
        <!-- SCORING CORE -->
        <div class="logic-section">
            <div class="logic-title">Core Scoring Logic</div>
            <div class="sub-header">Base Score</div>
            <div class="logic-card" style="font-size:0.8rem; color:#718096; margin-bottom:15px; background:#f0fff4; border-color:#c6f6d5; color:#276749;">
                The base score represents the baseline (nothing stands out) expected quality. The buffer (100 minus base) is distributed among section Pros. Use a lower base score if you mark every Pro you detect. Use a higher base score if you only mark Pros that significantly exceed expectations.
            </div>
            <div class="logic-card">
                <div class="slider-row">
                    <div class="slider-header"><span>Score</span><span id="lbl_base" class="slider-val">88</span></div>
                    <input type="range" min="50" max="95" value="88" id="sl_base" oninput="updateBase(this.value)">
                    <div style="font-size:0.75rem; color:#718096; margin-top:4px;">Buffer (Available Points): <b id="lbl_buffer">12</b></div>
                </div>
            </div>

            <div class="sub-header">Pros Importance by Section (Relative Weights)</div>
            <div class="logic-card">
                <div class="slider-row"><div class="slider-header"><span>Nose</span><span id="lbl_wt_nose" class="slider-val">33%</span></div><input type="range" min="1" max="100" value="33" id="sl_nose" oninput="updateWeights()"></div>
                <div class="slider-row"><div class="slider-header"><span>Palate</span><span id="lbl_wt_palate" class="slider-val">33%</span></div><input type="range" min="1" max="100" value="33" id="sl_palate" oninput="updateWeights()"></div>
                <div class="slider-row"><div class="slider-header"><span>Aftertaste</span><span id="lbl_wt_finish" class="slider-val">33%</span></div><input type="range" min="1" max="100" value="33" id="sl_finish" oninput="updateWeights()"></div>
            </div>
        </div>

        <!-- PROS WEIGHTS -->
        <div class="logic-section">
            <div class="logic-title">Pros: Weight Distribution</div>
            <div class="logic-card" style="font-size:0.8rem; color:#718096; margin-bottom:15px; background:#f0fff4; border-color:#c6f6d5; color:#276749;">
                Pros within each section compete for available points. Higher weights claim a larger share of the section's points.
            </div>
            
            <div id="container_pros_scoring"></div>
        </div>

        <!-- FLAWS PENALTIES -->
        <div class="logic-section">
            <div class="logic-title">Flaws: Penalties</div>
            <div id="container_flaws_scoring"></div>
        </div>

        <!-- MASKS -->
        <div class="logic-section">
            <div class="logic-title">Masks</div>
            <div class="logic-card" style="font-size:0.8rem; color:#718096; margin-bottom:15px; background:#f0fff4; border-color:#c6f6d5; color:#276749;">Link each Balance Flaw to related specific flaws. The system applies only the greater penalty: either the Balance Flaw or the sum of its linked flaws.</div>
            <div id="container_masks"></div>
        </div>

        <!-- TRUE TO CONFIGURATION -->
        <div class="logic-section">
            <div class="logic-title">True To: Typicity & Origins</div>
            
            <div class="logic-card" style="font-size:0.8rem; color:#718096; margin-bottom:15px; background:#f0fff4; border-color:#c6f6d5; color:#276749;">
               This acts as a <em>Bonus</em> for entry-level wines (rewarding character) and a <em>Malus</em> for great wines (punishing inauthenticity).
                <ul style="margin:5px 0 0 0; padding-left:20px;">
            </div>


    <!-- 0. NEW: Universal Quality Floor (The Pivot Point) -->
    <div class="sub-header">Entry Wines Threshold</div>
    <div class="logic-card" style="margin-bottom:20px;">
        <div class="slider-row">
            <div class="slider-header">
                <span>Max score of Entry-Level wines</span>
                <span id="lbl_tt_floor" class="slider-val">85</span>
            </div>
            <!-- Range: 50 to 95. Default 85. -->
            <input type="range" id="sl_tt_floor" min="50" max="95" step="1" value="85" oninput="updateTTFloor(this.value)">
            <div style="font-size:0.75rem; color:#718096; margin-top:8px;">
                Wines with this score and below are treated as 'entry-level' with naturally zero expectations of showing its origins.
            </div>
        </div>
    </div>

            <!-- 1. Global Impact Slider -->
            <div class="sub-header">MAXIMUM IMPACT</div>
            <div class="logic-card" style="margin-bottom:20px;">
                 <div class="slider-row">
                    <div class="slider-header">
                        <span>Max size of Bonus/Malus</span>
                        <!-- Label now shows POINTS -->
                        <span id="lbl_tt_impact" class="slider-val">1.5 pts</span>
                    </div>
                    <!-- Range: 0 to 5 points, step 0.5 -->
                    <input type="range" min="0" max="5" step="0.5" value="1.5" id="sl_tt_impact" oninput="updateTTImpact(this.value)">
                    <div style="font-size:0.75rem; color:#718096; margin-top:8px;">
                        How many points would you subtract from a 100-pointer for failing your 'true to' criteria?
                    </div>
                </div>
            </div>

  
            <!-- 2. Individual Weights Container -->
            <div class="sub-header">COMPONENT WEIGHTS</div>
            <div class="logic-card" style="margin-bottom:15px;">
                <div style="font-size:0.8rem; color:#718096; margin-bottom:10px;">
                    How is that bonus/malus distributed? Define the proportion of the score controlled by each element below.
                </div>
                <div id="container_trueto_weights"></div>
            </div>
        </div>



        <!-- AI SETTINGS -->
        <div class="logic-section">
            <div class="logic-title">AI Configuration</div>
            <div class="logic-card">
                <div class="ai-input-group"><label>Critic Style (Persona)</label><textarea id="ai_style" rows="2"></textarea></div>
                <div class="ai-input-group"><label>Prompt Template (Use {{WINE_TYPE}})</label><textarea id="ai_prompt" rows="3"></textarea></div>
                
                <div style="margin-top:20px; padding-top:10px; border-top:1px dashed #e2e8f0;">
                    <div class="ai-input-group"><label>Tone: Critical</label><textarea id="ai_tone_crit" rows="2"></textarea></div>
                    <div class="ai-input-group"><label>Tone: Neutral</label><textarea id="ai_tone_neut" rows="2"></textarea></div>
                    <div class="ai-input-group"><label>Tone: Praising</label><textarea id="ai_tone_prais" rows="2"></textarea></div>
                    <div class="ai-input-group"><label>Tone: Ecstatic</label><textarea id="ai_tone_ecst" rows="2"></textarea></div>
                </div>
            </div>
        </div>

    </div>
</div>

<div class="footer">
    <button id="btnBack" class="btn-back hidden" onclick="goToStep1()">&larr; Back</button>
    <button id="btnNext" class="btn-next" onclick="goToStep2()">Next: Scoring logic&rarr;</button>
    <button id="btnSave" class="btn-next hidden" style="background:#2f855a;" onclick="saveProfile()">ðŸ’¾ SAVE PROFILE</button>
</div>


<!-- METHODOLOGY MODAL -->
<div id="guideModal" class="hidden" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000; display:flex; justify-content:center; align-items:center; backdrop-filter:blur(2px);">
    <div style="background:white; width:90%; max-width:600px; max-height:85vh; border-radius:12px; box-shadow:0 10px 25px rgba(0,0,0,0.2); display:flex; flex-direction:column;">
        
        <div style="padding:15px 20px; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center;">
            <h2 style="margin:0; font-size:1.1rem; color:#2d3748;">Scoring Methodology</h2>
            <button onclick="toggleGuide()" style="border:none; background:none; font-size:1.5rem; cursor:pointer; color:#718096;">&times;</button>
        </div>

        <div style="padding:20px; overflow-y:auto; line-height:1.6; color:#4a5568; font-size:0.9rem;">
            <p style="margin-top:0;">This system evaluates a wine's potential and structure through five sequential steps:</p>

            <h4 style="margin:15px 0 5px 0; color:#2d3748;">1. Base Score & The Buffer</h4>
            <p style="margin:0;">Every evaluation begins with a <strong>Base Score</strong> (e.g., 88), representing a technically correct but undistinguished wine. The remaining points (up to 100) form the <strong>"Buffer,"</strong> a space for potential that the wine must actively earn.</p>

            <h4 style="margin:15px 0 5px 0; color:#2d3748;">2. Positive Attributes (Pros)</h4>
            <p style="margin:0;">The wine fills this Buffer by demonstrating quality across <strong>Nose</strong>, <strong>Palate</strong>, and <strong>Aftertaste</strong>. Each phase controls a specific share of the points. A wine cannot rely solely on aroma; it must deliver substance and length.</p>

            <h4 style="margin:15px 0 5px 0; color:#2d3748;">3. Individual Flaws</h4>
            <p style="margin:0;">Specific defects (e.g., <em>Volatile Acidity, Greenness</em>) trigger direct, fixed point deductions.</p>

            <h4 style="margin:15px 0 5px 0; color:#2d3748;">4. Structural Balance & Absorption</h4>
            <p style="margin:0;">We use <strong>Smart Masking</strong> logic. If a wine is marked as <em>Disjointed</em>, this structural failure often "masks" specific flaws like High Alcohol. The system applies the logic that best reflects the severity, ensuring the wine isn't penalized twice for the same underlying problem.</p>

            <h4 style="margin:15px 0 5px 0; color:#2d3748;">5. Fidelity to Origins (Sliding Scale)</h4>
            <p style="margin:0;">This is a swinging bonus/malus parameter:</p>
            <ul style="padding-left:20px; margin:5px 0;">
                <li>An entry-level wine that clearly shows its roots receives maximum bonus. Following a sliding scale, this bonus decreases as wine quality rises, eventually reaching zero for perfect wines.</li>
                <li>Malus goes to the opposite direction: a 100 point wine that fails to be true to origins receives maximum malus. The penalty then decreases on a sliding scale reaching zero for entry-level wines.</li>
            </ul>
        </div>
        
        <div style="padding:15px; border-top:1px solid #e2e8f0; text-align:right;">
            <button onclick="toggleGuide()" style="background:#2d3748; color:white; border:none; padding:8px 20px; border-radius:6px; font-weight:600; cursor:pointer;">Close</button>
        </div>
    </div>
</div>

<!-- DESIGN GUIDELINES MODAL -->
<div id="designGuideModal" class="hidden" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000; display:flex; justify-content:center; align-items:center; backdrop-filter:blur(2px);">
    <div style="background:white; width:90%; max-width:600px; max-height:85vh; border-radius:12px; box-shadow:0 10px 25px rgba(0,0,0,0.2); display:flex; flex-direction:column;">
        
        <div style="padding:15px 20px; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center;">
            <h2 style="margin:0; font-size:1.1rem; color:#2d3748;">Profile Design Guidelines</h2>
            <button onclick="toggleDesignGuide()" style="border:none; background:none; font-size:1.5rem; cursor:pointer; color:#718096;">&times;</button>
        </div>

        <div style="padding:20px; overflow-y:auto; line-height:1.6; color:#4a5568; font-size:0.9rem;">
            <h4 style="margin:0 0 5px 0; color:#2d3748;">1. Cross-Section Symmetry</h4>
            <p style="margin:0 0 15px 0;">Aim for the same number of Flaws, Neutral Traits, and Pros across sections (Nose, Palate, Finish)</p>

            <h4 style="margin:0 0 5px 0; color:#2d3748;">2. Types Coverage</h4>
            <p style="margin:0 0 15px 0;">The lists for Balance and Profile must be complete. Every single wine of this profile in existence must fall into exactly one of these categories. For example, a fruit profile cannot just be "Citrus" or "Tropical"â€”it must span the entire spectrum from under-ripe to over-ripe so nothing is left out.</p>

            <h4 style="margin:0 0 5px 0; color:#2d3748;">3. Pros Conflict</h4>
            <p style="margin:0 0 15px 0;">The Pros in each section must represent distinct, often opposing styles of excellence. You shouldn't list "Rich" and "Powerful" (similar). You should list "Rich" vs. "Precise" vs. "Complex", so you can define <em>why</em> the wine is good.</p>

            <h4 style="margin:0 0 5px 0; color:#2d3748;">4. Flaws vs. Traits</h4>
            <ul style="margin:0 0 15px 0; padding-left:20px;">
                <li><strong>Traits:</strong> Neutral stylistic choices (e.g., "Oak Spice" or "Reduction"). These are flavour descriptors, not judgments.</li>
                <li><strong>Flaws:</strong> Deal-breakers that ruin the wine or betray its origin (e.g., "Premox/Cider" or "Tropical/Heavy"). If Montrachet tastes like cheap Chardonnay from a hot climate, it's a flaw.</li>
            </ul>
        </div>
        
        <div style="padding:15px; border-top:1px solid #e2e8f0; text-align:right;">
            <button onclick="toggleDesignGuide()" style="background:#2d3748; color:white; border:none; padding:8px 20px; border-radius:6px; font-weight:600; cursor:pointer;">Close</button>
        </div>
    </div>
</div>



<script>


    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycby3mzUfj4MRGGdUu_l_3bnpDJXyHFC8jvr0JPfY8BzrD_yeqAbWA0fEPOfmGQOcveAe/exec";
    const TASTING_URL = SCRIPT_URL;

// --- NEW AUTH LOGIC ---
let CURRENT_USER = localStorage.getItem('wta_user_id');

// If no user is found (e.g. they came directly to this page), ask them.
if (!CURRENT_USER) {
    CURRENT_USER = prompt("Enter your email/ID to access your profiles:");
    if(CURRENT_USER) {
        localStorage.setItem('wta_user_id', CURRENT_USER);
    } else {
        CURRENT_USER = "demo_user"; // Fallback
    }
}


function apiCall(action, params, isPost = false) {
    // Automatically append userId to URL
    let url = `${SCRIPT_URL}?action=${action}&userId=${encodeURIComponent(CURRENT_USER)}`;
    
    if (isPost) {
        const payload = params || {};
        payload.userId = CURRENT_USER; // Ensure it's in body too for POST
        payload.action = action;
        return fetch(SCRIPT_URL, { method: 'POST', body: JSON.stringify(payload) }).then(r => r.json());
    }
    
    if (params) {
        for (const [key, value] of Object.entries(params)) {
            url += `&${key}=${encodeURIComponent(value)}`;
        }
    }
    return fetch(url).then(r => r.json());
}


    
    // STATE
    let config = {
        name: "", wineType: "",
        nose: { flaws: [], traits: [], pros: [] },
        palate: { flaws: [], traits: [], pros: [] },
        finish: { flaws: [], traits: [], pros: [] },
        balance: [], profile: [], true_to: [],
        scoring: { baseScore: 88, maxBuffer: 12, sectionWeights: { nose: 33, palate: 33, finish: 33 } },
        ai: { tones: {} },
        itemScores: {}, masks: {} 
    };

    window.onload = function() { fetchProfiles(); renderStep1(); };

    // --- STEP 1 RENDERER ---
    function renderStep1() {
        ['nose','palate','finish'].forEach(sec => {
            const col = document.getElementById('col_'+sec);
            col.innerHTML = `<div class="section-header">${sec.toUpperCase()}</div>
                <div class="list-card lc-flaws" id="ed_${sec}_flaws"></div>
                <div class="list-card lc-traits" id="ed_${sec}_traits"></div>
                <div class="list-card lc-pros" id="ed_${sec}_pros"></div>`;
            ['flaws','traits','pros'].forEach(type => {
                renderList(`ed_${sec}_${type}`, config[sec][type], (i,v)=>config[sec][type][i]=v, (i)=>{config[sec][type].splice(i,1); renderStep1()}, ()=>{config[sec][type].push(""); renderStep1()}, type);
            });
        });
        renderList('editor_balance', config.balance, (i,v)=>config.balance[i]=v, (i)=>{config.balance.splice(i,1); renderStep1()}, ()=>{config.balance.push(""); renderStep1()}, "Balance");
        renderList('editor_profile', config.profile, (i,v)=>config.profile[i]=v, (i)=>{config.profile.splice(i,1); renderStep1()}, ()=>{config.profile.push(""); renderStep1()}, "Profile");
        renderList('editor_true_to', config.true_to, (i,v)=>config.true_to[i]=v, (i)=>{config.true_to.splice(i,1); renderStep1()}, ()=>{config.true_to.push(""); renderStep1()}, "True To");
    }

    function renderList(id, arr, onEdit, onDel, onAdd, lbl) {
        const el = document.getElementById(id);
        if(!el) return;
        el.innerHTML = `<div class="list-title"><span>${lbl}</span> <span style="opacity:0.5">${arr.length}</span></div>`;
        arr.forEach((val, idx) => {
            let row = document.createElement('div'); row.className = 'item-row';
            row.innerHTML = `<input type="text" value="${val}" oninput="this.dataset.val=this.value"><button class="btn-del">&times;</button>`;
            row.querySelector('input').onchange = (e) => onEdit(idx, e.target.value);
            row.querySelector('.btn-del').onclick = () => onDel(idx);
            el.appendChild(row);
        });
        let btn = document.createElement('button'); btn.className = 'btn-add'; btn.innerText = "+ Add " + lbl; btn.onclick = onAdd;
        el.appendChild(btn);
    }

    // --- NAVIGATION ---
    function goToStep2() {
        var nameVal = document.getElementById('meta_name').value.trim();
        var wineTypeVal = document.getElementById('meta_wineType').value;

        if(!nameVal) { alert("Please name your profile."); return; }

        // NOTE: do NOT overwrite config.name here (it breaks duplicate-name detection on save)
        config.wineType = wineTypeVal;

        document.getElementById('step1').classList.add('hidden');
        document.getElementById('step2').classList.remove('hidden');
        document.getElementById('loaderBox').classList.add('hidden');
        document.getElementById('stepBadge').innerText = "Step 2: Logic & Scoring";
        document.getElementById('btnDesignHelp').classList.add('hidden');         
        document.getElementById('btnHelp').classList.remove('hidden');  
        document.getElementById('btnHelp').classList.remove('hidden'); 
        document.getElementById('btnBack').classList.remove('hidden');
        document.getElementById('btnNext').classList.add('hidden');
        document.getElementById('btnSave').classList.remove('hidden');
        window.scrollTo(0,0);

        renderStep2();
    }

    function goToStep1() {
        document.getElementById('step2').classList.add('hidden');
        document.getElementById('step1').classList.remove('hidden');
        document.getElementById('btnDesignHelp').classList.remove('hidden'); 
        document.getElementById('btnHelp').classList.add('hidden');    
        document.getElementById('loaderBox').classList.remove('hidden');
        document.getElementById('stepBadge').innerText = "Step 1: Structure";
        document.getElementById('btnHelp').classList.add('hidden');
        document.getElementById('btnBack').classList.add('hidden');
        document.getElementById('btnNext').classList.remove('hidden');
        document.getElementById('btnSave').classList.add('hidden');
    }

    // --- STEP 2 RENDERER ---
    function renderStep2() {
        // 1. Core Logic
        document.getElementById('sl_base').value = config.scoring.baseScore || 88;
        updateBase(config.scoring.baseScore || 88);


// Scale factor: 100% -> ~15 on slider
const scale = 15; 
document.getElementById('sl_nose').value = Math.round(config.scoring.sectionWeights.nose);
document.getElementById('sl_palate').value = Math.round(config.scoring.sectionWeights.palate);
document.getElementById('sl_finish').value = Math.round(config.scoring.sectionWeights.finish);

updateWeights();

        // 2. Pros (Grouped by Section)
        const cPros = document.getElementById('container_pros_scoring'); cPros.innerHTML = "";
        ['nose','palate','finish'].forEach(sec => {
            if(config[sec].pros.length === 0) return;
            const sub = document.createElement('div');
            sub.innerHTML = `<div class="sub-header">${sec} PROS</div><div class="score-grid"></div>`;
            const grid = sub.querySelector('.score-grid');
            
            config[sec].pros.forEach(item => { 
                if(!item) return;
                let val = config.itemScores[item] !== undefined ? config.itemScores[item] : 0; 
                config.itemScores[item] = val; 
                grid.appendChild(mkSliderRow(item, val, 0, 3, 0.5, true));
            });
            cPros.appendChild(sub);
        });

        // 3. Flaws (Split: Balance vs Section)
        const cFlaws = document.getElementById('container_flaws_scoring'); cFlaws.innerHTML = "";
        let allFlaws = []; // Track for mask builder

        // A. Global Balance Flaws
        if(config.balance.length > 0) {
            const sub = document.createElement('div');
            sub.innerHTML = `<div class="sub-header" style="color:#e53e3e">GLOBAL BALANCE FAULTS</div><div class="score-grid"></div>`;
            const grid = sub.querySelector('.score-grid');
            config.balance.forEach(item => {
                if(!item) return;
                let val = config.itemScores[item] !== undefined ? config.itemScores[item] : 0;
                config.itemScores[item] = val;
                grid.appendChild(mkSliderRow(item, val, -10, 0, 1, false));
            });
            cFlaws.appendChild(sub);
        }

        // B. Section Flaws
        ['nose','palate','finish'].forEach(sec => {
            if(config[sec].flaws.length === 0) return;
            const sub = document.createElement('div');
            sub.innerHTML = `<div class="sub-header">${sec} FLAWS</div><div class="score-grid"></div>`;
            const grid = sub.querySelector('.score-grid');
            
            config[sec].flaws.forEach(item => { 
                if(!item) return;
                allFlaws.push(item);
                let val = config.itemScores[item] !== undefined ? config.itemScores[item] : 0; 
                config.itemScores[item] = val; 
                grid.appendChild(mkSliderRow(item, val, -10, 0, 1, false));
            });
            cFlaws.appendChild(sub);
        });

        // 4. Masks (Rebuild with allFlaws)
        renderMasks(allFlaws);


        // 5. True To Logic
        
        // A. Init Impact Slider (Direct Points)
        // Default to 1.5 points if missing
        let ttPoints = (config.scoring && config.scoring.trueToImpactPct !== undefined) ? config.scoring.trueToImpactPct : 1.5;
        document.getElementById('sl_tt_impact').value = ttPoints;
        updateTTImpact(ttPoints); // Updates label and config

        // B. Init Weights Sliders
        const cTrueTo = document.getElementById('container_trueto_weights'); cTrueTo.innerHTML = "";
        if(config.true_to && config.true_to.length > 0) {
            const sub = document.createElement('div');
            sub.innerHTML = `<div class="score-grid"></div>`;
            const grid = sub.querySelector('.score-grid');
            
            config.true_to.forEach(item => {
                if(!item) return;
                let val = config.itemScores[item] !== undefined ? config.itemScores[item] : 1;
                config.itemScores[item] = val;
                grid.appendChild(mkSliderRow(item, val, 0, 3, 0.5, true));
            });
            cTrueTo.appendChild(sub);
        } else {
             cTrueTo.innerHTML = "<div style='font-style:italic; color:#a0aec0; padding:10px;'>No 'True To' items defined in Step 1.</div>";
        }

	// C. Floor
    var savedFloor = (config.scoring.trueToFloor !== undefined) ? config.scoring.trueToFloor : 85;
    
    var sliderEl = document.getElementById('sl_tt_floor');
    if(sliderEl) {
        sliderEl.value = savedFloor;
        updateTTFloor(savedFloor);
    }

        // 6. AI
        document.getElementById('ai_style').value = config.ai.criticStyle || "Classic British";
        document.getElementById('ai_prompt').value = config.ai.userPromptTemplate || "Assess this {{WINE_TYPE}}...";
        document.getElementById('ai_tone_crit').value = config.ai.tones.critical || "";
        document.getElementById('ai_tone_neut').value = config.ai.tones.neutral || "";
        document.getElementById('ai_tone_prais').value = config.ai.tones.praising || "";
        document.getElementById('ai_tone_ecst').value = config.ai.tones.ecstatic || "";
    }

    function renderMasks(allFlaws) {
        const cMasks = document.getElementById('container_masks'); cMasks.innerHTML = "";
        config.balance.forEach(bal => {
            if(!bal) return;
            // Only render mask builder for Balance items (typically 'Disjointed' etc)
            const card = document.createElement('div'); card.style.cssText = "border:1px solid #e2e8f0; border-radius:8px; padding:10px; background:#fff; margin-bottom:10px;";
            const head = document.createElement('div'); head.style.cssText = "font-weight:700; color:#2d3748; margin-bottom:8px; border-bottom:1px solid #eee; padding-bottom:5px;"; 
            head.innerText = `"${bal}" is connected with:`;
            
            const opts = document.createElement('div'); opts.style.cssText = "display:flex; flex-wrap:wrap; gap:8px;";
            
            let activeMasks = config.masks[bal] || [];

            allFlaws.forEach(flaw => {
                if(flaw === bal) return;
                let pill = document.createElement('div'); 
                pill.style.cssText = "font-size:0.75rem; padding:4px 8px; background:#edf2f7; border-radius:12px; cursor:pointer; border:1px solid transparent; user-select:none;";
                if(activeMasks.includes(flaw)) {
                    pill.style.background = "#fed7d7"; pill.style.color = "#c53030"; pill.style.borderColor = "#fc8181"; pill.style.fontWeight = "600";
                }
                pill.innerText = flaw;
                pill.onclick = function() {
                    if(activeMasks.includes(flaw)) {
                         activeMasks = activeMasks.filter(x => x !== flaw);
                         pill.style.background = "#edf2f7"; pill.style.color = "inherit"; pill.style.fontWeight = "normal"; pill.style.borderColor = "transparent";
                    } else {
                         activeMasks.push(flaw);
                         pill.style.background = "#fed7d7"; pill.style.color = "#c53030"; pill.style.fontWeight = "600"; pill.style.borderColor = "#fc8181";
                    }
                    config.masks[bal] = activeMasks;
                };
                opts.appendChild(pill);
            });
            card.appendChild(head); card.appendChild(opts); cMasks.appendChild(card);
        });
    }

    function mkSliderRow(label, val, min, max, step, isPro) {
        const div = document.createElement('div'); div.className = 'score-row';

        var sliderMin = min;
        var sliderMax = max;
        var sliderVal = val;

        // Reverse flaw sliders:
        // UI goes 0 (left) -> 10 (right), stored value goes 0 -> -10
        if (!isPro) {
            sliderMin = 0;
            sliderMax = Math.abs(min);     // e.g. min=-10 => sliderMax=10
            sliderVal = Math.abs(val);     // e.g. val=-4 => sliderVal=4
        }

div.innerHTML = `
    <div class="score-top">
        <span class="score-lbl">${label}</span>
        <span data-label="${label}" class="score-val ${isPro?'val-pos':'val-neg'}">${val}</span>
    </div>
    <input type="range" min="${sliderMin}" max="${sliderMax}" step="${step}" value="${sliderVal}" oninput="updateItemScore('${label.replace(/'/g, "\\'")}', this.value, ${isPro})">
`;
        return div;
    }

window.updateItemScore = function(label, val, isPro) {
    var n = parseFloat(val);
    var stored = isPro ? n : -n;

    config.itemScores[label] = stored;
    
    // Escape the label for use in getElementById
    var safeId = 'dsp_' + label.replace(/[^a-zA-Z0-9]/g, '_');
    var displayEl = document.querySelector('[data-label="' + label + '"]');
    if(displayEl) displayEl.innerText = stored;
}


    window.updateBase = function(val) {
        document.getElementById('lbl_base').innerText = val;
        document.getElementById('lbl_buffer').innerText = 100 - val;
        config.scoring.baseScore = parseInt(val);
        config.scoring.maxBuffer = 100 - val;
    }

    window.updateWeights = function() {
        const n = parseInt(document.getElementById('sl_nose').value);
        const p = parseInt(document.getElementById('sl_palate').value);
        const f = parseInt(document.getElementById('sl_finish').value);
        const total = n + p + f;
        config.scoring.sectionWeights = {
            nose: (n/total)*100, palate: (p/total)*100, finish: (f/total)*100
        };
        document.getElementById('lbl_wt_nose').innerText = Math.round(config.scoring.sectionWeights.nose) + "%";
        document.getElementById('lbl_wt_palate').innerText = Math.round(config.scoring.sectionWeights.palate) + "%";
        document.getElementById('lbl_wt_finish').innerText = Math.round(config.scoring.sectionWeights.finish) + "%";
    }

    window.updateTTImpact = function(val) {
        // Just show points and save points. No math.
        document.getElementById('lbl_tt_impact').innerText = val + " pts";
        if(!config.scoring) config.scoring = {};
        config.scoring.trueToImpactPct = parseFloat(val); // We keep the variable name to avoid schema errors, but it stores POINTS now.
    }


window.updateTTFloor = function(val) {
    document.getElementById('lbl_tt_floor').innerText = val;
    if(!config.scoring) config.scoring = {};
    // Ensure we parse it as a number so math works later
    config.scoring.trueToFloor = parseInt(val);
}



    // --- SAVE ---
    function saveProfile() {
        const btn = document.getElementById('btnSave'); 
        
        // 1. Validate Name Uniqueness
        var finalName = document.getElementById('meta_name').value.trim();
        if(!finalName) { alert("Please enter a profile name."); return; }
        
        var existingNames = [];
        var opts = document.getElementById('templateSelector').options;
        for(var i = 0; i < opts.length; i++) {
            if(opts[i].value) existingNames.push(opts[i].value);
        }
        
        if(existingNames.indexOf(finalName) !== -1 && finalName !== config.name) {
            alert("A profile named '" + finalName + "' already exists. Please choose a different name.");
            return;
        }
        
        btn.innerText = "SAVING..."; 
        btn.disabled = true;
        
        config.name = finalName; 
        
        // Clone config to create the save object
        let final = JSON.parse(JSON.stringify(config)); 
        
        // CLEANUP: Remove runtime-only state
        delete final.itemScores; 
        delete final.masks; // <--- Prevents the root-level duplicate
        
        // FILTER: Only save masks for Balance items that currently exist
        let cleanMasks = {};
        config.balance.forEach(bItem => {
            if(bItem && config.masks[bItem]) {
                cleanMasks[bItem] = config.masks[bItem];
            }
        });

        // BUILD SCORING RULES
        final.scoringRules = { 
            pros: {nose:{}, palate:{}, finish:{}}, 
            penalties: {}, 
            masks: cleanMasks,
            trueToWeights: {} 
        };
        
        // Map scores
        ['nose','palate','finish'].forEach(sec => {
            final[sec].pros.forEach(i => { if(i) final.scoringRules.pros[sec][i] = config.itemScores[i] || 0; });
            final[sec].flaws.forEach(i => { if(i) final.scoringRules.penalties[i] = config.itemScores[i] || 0; });
        });
        final.balance.forEach(i => { if(i) final.scoringRules.penalties[i] = config.itemScores[i] || 0; });

        final.true_to.forEach(i => {
            if(i) final.scoringRules.trueToWeights[i] = config.itemScores[i] || 0;
        });

        final.ai = {
            criticStyle: document.getElementById('ai_style').value,
            userPromptTemplate: document.getElementById('ai_prompt').value,
            tones: {
                critical: document.getElementById('ai_tone_crit').value,
                neutral: document.getElementById('ai_tone_neut').value,
                praising: document.getElementById('ai_tone_prais').value,
                ecstatic: document.getElementById('ai_tone_ecst').value
            }
        };

        apiCall("saveProfile", { name: final.name, config: final }, true)
        .then(d => {
            if(d.result === "success") { 
                alert("Profile saved successfully!");
                btn.innerText = "ðŸ’¾ SAVE PROFILE";
                btn.disabled = false;
                if (window.history.length > 1) {
                    window.history.back();
                } else {
                    window.location.href = TASTING_URL;
                }
            }
            else { 
                throw new Error(d.error || "Unknown server error");
            }
        })
        .catch(err => {
            alert("Save Failed: " + err.message); 
            btn.innerText = "ðŸ’¾ SAVE PROFILE";
            btn.disabled = false; 
        });
    }

    // --- LOADER ---
    function fetchProfiles() {
        const sel = document.getElementById('templateSelector');
        // Clear options, keep placeholder
        while (sel.options.length > 1) { sel.remove(1); }

        apiCall("getProfilesList")
        .then(d => { 
            if(d.profiles && d.profiles.length > 0) {
                d.profiles.forEach(p => { 
                    let opt = document.createElement('option'); 
                    // Backend now sends objects: {name, visibility, author}
                    opt.value = p.name; 
                    
                    if(p.visibility === 'public') {
                        opt.text = `ðŸŒ ${p.name}`;
                        opt.dataset.type = "public";
                    } else {
                        opt.text = `ðŸ‘¤ ${p.name}`;
                        opt.dataset.type = "private";
                    }
                    sel.add(opt); 
                }); 
            }
            updateDeleteVisibility();
        });
    }


    function loadSelectedTemplate() {
        const name = document.getElementById('templateSelector').value;
        if(!name) return;
        
        apiCall("getProfile", { name: name })
        .then(data => {
            config = data; 
            
            // Smart naming: check if "Name (Copy)" exists, if yes, try "Name (Copy 2)", etc.
            var baseName = data.name + " (Copy)";
            var candidateName = baseName;
            var counter = 2;
            
            // Get list of existing names from dropdown
            var existingNames = [];
            var opts = document.getElementById('templateSelector').options;
            for(var i = 0; i < opts.length; i++) {
                if(opts[i].value) existingNames.push(opts[i].value);
            }
            
            // Increment until unique
            while(existingNames.indexOf(candidateName) !== -1) {
                candidateName = data.name + " (Copy " + counter + ")";
                counter++;
            }
            
            config.name = candidateName;
            
            // Flatten scores
            config.itemScores = {};
            if(data.scoringRules) {
                if(data.scoringRules.penalties) Object.assign(config.itemScores, data.scoringRules.penalties);
                if(data.scoringRules.trueToWeights) Object.assign(config.itemScores, data.scoringRules.trueToWeights);
                if(data.scoringRules.pros) {
                    Object.values(data.scoringRules.pros).forEach(secMap => Object.assign(config.itemScores, secMap));
                }
            }
            config.masks = data.scoringRules?.masks || {};
            
            document.getElementById('meta_name').value = config.name;
            document.getElementById('meta_wineType').value = config.wineType;
            renderStep1();
        });
    }

    function toggleGuide() {
        const modal = document.getElementById('guideModal');
        // Check if currently hidden (using the class or inline style check)
        if (modal.classList.contains('hidden')) {
            modal.classList.remove('hidden');
        } else {
            modal.classList.add('hidden');
        }
    }

    function toggleDesignGuide() {
        const modal = document.getElementById('designGuideModal');
        if (modal.classList.contains('hidden')) {
            modal.classList.remove('hidden');
        } else {
            modal.classList.add('hidden');
        }
    }


    function updateDeleteVisibility() {
        const sel = document.getElementById('templateSelector');
        const btn = document.getElementById('btnDeleteTemplate');
        
        if (sel.selectedIndex <= 0) {
            btn.style.display = 'none';
            return;
        }

        const selectedOption = sel.options[sel.selectedIndex];
        // Only show delete button for Private profiles
        if (selectedOption.dataset.type === "private") {
            btn.style.display = 'block';
        } else {
            btn.style.display = 'none';
        }
    }

    function deleteSelectedTemplate() {
        const sel = document.getElementById('templateSelector');
        const nameToDelete = sel.value;
        
        if(!nameToDelete) return;
        
        if(!confirm(`PERMANENTLY DELETE profile "${nameToDelete}"?\n\nThis cannot be undone.`)) return;

        const btn = document.getElementById('btnDeleteTemplate');
        const originalText = btn.innerText;
        btn.innerText = "...";
        btn.disabled = true;

        apiCall("deleteProfile", { name: nameToDelete }, true)
        .then(d => {
            if(d.error) {
                alert("Cannot Delete:\n" + d.error);
            } else {
                alert("Profile deleted.");
                fetchProfiles(); // Refresh list
                sel.value = "";  // Reset selection
            }
            btn.innerText = originalText;
            btn.disabled = false;
        })
        .catch(e => {
            alert("Network Error");
            btn.innerText = originalText;
            btn.disabled = false;
        });
    }

    

</script>


</body>
</html>
